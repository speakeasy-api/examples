/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { smartUnion } from "../../types/smartUnion.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

export type CreateBookingPaymentRequest = {
  /**
   * The ID of the booking to pay for.
   */
  bookingId: string;
  /**
   * Payment details
   */
  body: models.BookingPayment;
};

/**
 * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
 */
export const Currency = {
  Bam: "bam",
  Bgn: "bgn",
  Chf: "chf",
  Eur: "eur",
  Gbp: "gbp",
  Nok: "nok",
  Sek: "sek",
  Try: "try",
} as const;
/**
 * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
 */
export type Currency = OpenEnum<typeof Currency>;

/**
 * The type of entity that holds the account. This can be either `individual` or `company`.
 */
export const AccountType = {
  Individual: "individual",
  Company: "company",
} as const;
/**
 * The type of entity that holds the account. This can be either `individual` or `company`.
 */
export type AccountType = OpenEnum<typeof AccountType>;

/**
 * A bank account to take payment from. Must be able to make payments in the currency specified in the payment.
 */
export type BankAccount = {
  object?: "bank_account" | undefined;
  name: string;
  /**
   * The account number for the bank account, in string form. Must be a current account.
   */
  number: string;
  /**
   * The sort code for the bank account, in string form. Must be a six-digit number.
   */
  sortCode?: string | undefined;
  /**
   * The type of entity that holds the account. This can be either `individual` or `company`.
   */
  accountType: AccountType;
  /**
   * The name of the bank associated with the routing number.
   */
  bankName: string;
  /**
   * Two-letter country code (ISO 3166-1 alpha-2).
   */
  country: string;
};

/**
 * A card (debit or credit) to take payment from.
 */
export type Card = {
  object?: "card" | undefined;
  /**
   * Cardholder's full name as it appears on the card.
   */
  name: string;
  /**
   * The card number, as a string without any separators. On read all but the last four digits will be masked for security.
   */
  number: string;
  /**
   * Two-digit number representing the card's expiration month.
   */
  expMonth: number;
  /**
   * Four-digit number representing the card's expiration year.
   */
  expYear: number;
  addressCity?: string | undefined;
  addressCountry: string;
  addressPostCode?: string | undefined;
};

/**
 * The payment source to take the payment from. This can be a card or a bank account. Some of these properties will be hidden on read to protect PII leaking.
 */
export type Source = Card | BankAccount;

/**
 * The status of the payment, one of `pending`, `succeeded`, or `failed`.
 */
export const Status = {
  Pending: "pending",
  Succeeded: "succeeded",
  Failed: "failed",
} as const;
/**
 * The status of the payment, one of `pending`, `succeeded`, or `failed`.
 */
export type Status = OpenEnum<typeof Status>;

/**
 * A payment for a booking.
 */
export type CreateBookingPaymentResponseBody = {
  /**
   * Unique identifier for the payment. This will be a unique identifier for the payment, and is used to reference the payment in other objects.
   */
  id?: string | undefined;
  /**
   * Amount intended to be collected by this payment. A positive decimal figure describing the amount to be collected.
   */
  amount?: number | undefined;
  /**
   * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
   */
  currency?: Currency | undefined;
  /**
   * The payment source to take the payment from. This can be a card or a bank account. Some of these properties will be hidden on read to protect PII leaking.
   */
  source?: Card | BankAccount | undefined;
  /**
   * The status of the payment, one of `pending`, `succeeded`, or `failed`.
   */
  status?: Status | undefined;
  /**
   * The link to the booking resource.
   */
  links?: models.LinksBooking | undefined;
};

export type CreateBookingPaymentResponse = {
  headers: { [k: string]: Array<string> };
  result: CreateBookingPaymentResponseBody;
};

/** @internal */
export type CreateBookingPaymentRequest$Outbound = {
  bookingId: string;
  body: models.BookingPayment$Outbound;
};

/** @internal */
export const CreateBookingPaymentRequest$outboundSchema: z.ZodMiniType<
  CreateBookingPaymentRequest$Outbound,
  CreateBookingPaymentRequest
> = z.object({
  bookingId: z.string(),
  body: models.BookingPayment$outboundSchema,
});

export function createBookingPaymentRequestToJSON(
  createBookingPaymentRequest: CreateBookingPaymentRequest,
): string {
  return JSON.stringify(
    CreateBookingPaymentRequest$outboundSchema.parse(
      createBookingPaymentRequest,
    ),
  );
}

/** @internal */
export const Currency$inboundSchema: z.ZodMiniType<Currency, unknown> =
  openEnums.inboundSchema(Currency);

/** @internal */
export const AccountType$inboundSchema: z.ZodMiniType<AccountType, unknown> =
  openEnums.inboundSchema(AccountType);

/** @internal */
export const BankAccount$inboundSchema: z.ZodMiniType<BankAccount, unknown> = z
  .pipe(
    z.object({
      object: types.optional(types.literal("bank_account")),
      name: types.string(),
      number: types.string(),
      sort_code: types.optional(types.string()),
      account_type: AccountType$inboundSchema,
      bank_name: types.string(),
      country: types.string(),
    }),
    z.transform((v) => {
      return remap$(v, {
        "sort_code": "sortCode",
        "account_type": "accountType",
        "bank_name": "bankName",
      });
    }),
  );

export function bankAccountFromJSON(
  jsonString: string,
): SafeParseResult<BankAccount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BankAccount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BankAccount' from JSON`,
  );
}

/** @internal */
export const Card$inboundSchema: z.ZodMiniType<Card, unknown> = z.pipe(
  z.object({
    object: types.optional(types.literal("card")),
    name: types.string(),
    number: types.string(),
    exp_month: types.number(),
    exp_year: types.number(),
    address_city: types.optional(types.string()),
    address_country: types.string(),
    address_post_code: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "exp_month": "expMonth",
      "exp_year": "expYear",
      "address_city": "addressCity",
      "address_country": "addressCountry",
      "address_post_code": "addressPostCode",
    });
  }),
);

export function cardFromJSON(
  jsonString: string,
): SafeParseResult<Card, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Card$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Card' from JSON`,
  );
}

/** @internal */
export const Source$inboundSchema: z.ZodMiniType<Source, unknown> = smartUnion([
  z.lazy(() => Card$inboundSchema),
  z.lazy(() => BankAccount$inboundSchema),
]);

export function sourceFromJSON(
  jsonString: string,
): SafeParseResult<Source, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Source$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Source' from JSON`,
  );
}

/** @internal */
export const Status$inboundSchema: z.ZodMiniType<Status, unknown> = openEnums
  .inboundSchema(Status);

/** @internal */
export const CreateBookingPaymentResponseBody$inboundSchema: z.ZodMiniType<
  CreateBookingPaymentResponseBody,
  unknown
> = z.object({
  id: types.optional(types.string()),
  amount: types.optional(types.number()),
  currency: types.optional(Currency$inboundSchema),
  source: types.optional(
    smartUnion([
      z.lazy(() => Card$inboundSchema),
      z.lazy(() => BankAccount$inboundSchema),
    ]),
  ),
  status: types.optional(Status$inboundSchema),
  links: types.optional(models.LinksBooking$inboundSchema),
});

export function createBookingPaymentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateBookingPaymentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateBookingPaymentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateBookingPaymentResponseBody' from JSON`,
  );
}

/** @internal */
export const CreateBookingPaymentResponse$inboundSchema: z.ZodMiniType<
  CreateBookingPaymentResponse,
  unknown
> = z.pipe(
  z.object({
    Headers: z._default(z.record(z.string(), z.array(z.string())), {}),
    Result: z.lazy(() => CreateBookingPaymentResponseBody$inboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      "Headers": "headers",
      "Result": "result",
    });
  }),
);

export function createBookingPaymentResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateBookingPaymentResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateBookingPaymentResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateBookingPaymentResponse' from JSON`,
  );
}

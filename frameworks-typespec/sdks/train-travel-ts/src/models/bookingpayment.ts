/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { ClosedEnum } from "../types/enums.js";
import { smartUnion } from "../types/smartUnion.js";

/**
 * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
 */
export const Currency = {
  Bam: "bam",
  Bgn: "bgn",
  Chf: "chf",
  Eur: "eur",
  Gbp: "gbp",
  Nok: "nok",
  Sek: "sek",
  Try: "try",
} as const;
/**
 * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
 */
export type Currency = ClosedEnum<typeof Currency>;

/**
 * The type of entity that holds the account. This can be either `individual` or `company`.
 */
export const AccountType = {
  Individual: "individual",
  Company: "company",
} as const;
/**
 * The type of entity that holds the account. This can be either `individual` or `company`.
 */
export type AccountType = ClosedEnum<typeof AccountType>;

/**
 * A bank account to take payment from. Must be able to make payments in the currency specified in the payment.
 */
export type BankAccount = {
  object?: "bank_account" | undefined;
  name: string;
  /**
   * The account number for the bank account, in string form. Must be a current account.
   */
  number: string;
  /**
   * The sort code for the bank account, in string form. Must be a six-digit number.
   */
  sortCode?: string | undefined;
  /**
   * The type of entity that holds the account. This can be either `individual` or `company`.
   */
  accountType: AccountType;
  /**
   * The name of the bank associated with the routing number.
   */
  bankName: string;
  /**
   * Two-letter country code (ISO 3166-1 alpha-2).
   */
  country: string;
};

/**
 * A card (debit or credit) to take payment from.
 */
export type Card = {
  object?: "card" | undefined;
  /**
   * Cardholder's full name as it appears on the card.
   */
  name: string;
  /**
   * The card number, as a string without any separators. On read all but the last four digits will be masked for security.
   */
  number: string;
  /**
   * Card security code, 3 or 4 digits usually found on the back of the card.
   */
  cvc: string;
  /**
   * Two-digit number representing the card's expiration month.
   */
  expMonth: number;
  /**
   * Four-digit number representing the card's expiration year.
   */
  expYear: number;
  addressLine1?: string | undefined;
  addressLine2?: string | undefined;
  addressCity?: string | undefined;
  addressCountry: string;
  addressPostCode?: string | undefined;
};

/**
 * The payment source to take the payment from. This can be a card or a bank account. Some of these properties will be hidden on read to protect PII leaking.
 */
export type Source = Card | BankAccount;

/**
 * A payment for a booking.
 */
export type BookingPayment = {
  /**
   * Amount intended to be collected by this payment. A positive decimal figure describing the amount to be collected.
   */
  amount?: number | undefined;
  /**
   * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
   */
  currency?: Currency | undefined;
  /**
   * The payment source to take the payment from. This can be a card or a bank account. Some of these properties will be hidden on read to protect PII leaking.
   */
  source?: Card | BankAccount | undefined;
};

/** @internal */
export const Currency$outboundSchema: z.ZodMiniEnum<typeof Currency> = z.enum(
  Currency,
);

/** @internal */
export const AccountType$outboundSchema: z.ZodMiniEnum<typeof AccountType> = z
  .enum(AccountType);

/** @internal */
export type BankAccount$Outbound = {
  object?: "bank_account" | undefined;
  name: string;
  number: string;
  sort_code?: string | undefined;
  account_type: string;
  bank_name: string;
  country: string;
};

/** @internal */
export const BankAccount$outboundSchema: z.ZodMiniType<
  BankAccount$Outbound,
  BankAccount
> = z.pipe(
  z.object({
    object: z.optional(z.literal("bank_account")),
    name: z.string(),
    number: z.string(),
    sortCode: z.optional(z.string()),
    accountType: AccountType$outboundSchema,
    bankName: z.string(),
    country: z.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      sortCode: "sort_code",
      accountType: "account_type",
      bankName: "bank_name",
    });
  }),
);

export function bankAccountToJSON(bankAccount: BankAccount): string {
  return JSON.stringify(BankAccount$outboundSchema.parse(bankAccount));
}

/** @internal */
export type Card$Outbound = {
  object?: "card" | undefined;
  name: string;
  number: string;
  cvc: string;
  exp_month: number;
  exp_year: number;
  address_line1?: string | undefined;
  address_line2?: string | undefined;
  address_city?: string | undefined;
  address_country: string;
  address_post_code?: string | undefined;
};

/** @internal */
export const Card$outboundSchema: z.ZodMiniType<Card$Outbound, Card> = z.pipe(
  z.object({
    object: z.optional(z.literal("card")),
    name: z.string(),
    number: z.string(),
    cvc: z.string(),
    expMonth: z.int(),
    expYear: z.int(),
    addressLine1: z.optional(z.string()),
    addressLine2: z.optional(z.string()),
    addressCity: z.optional(z.string()),
    addressCountry: z.string(),
    addressPostCode: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      expMonth: "exp_month",
      expYear: "exp_year",
      addressLine1: "address_line1",
      addressLine2: "address_line2",
      addressCity: "address_city",
      addressCountry: "address_country",
      addressPostCode: "address_post_code",
    });
  }),
);

export function cardToJSON(card: Card): string {
  return JSON.stringify(Card$outboundSchema.parse(card));
}

/** @internal */
export type Source$Outbound = Card$Outbound | BankAccount$Outbound;

/** @internal */
export const Source$outboundSchema: z.ZodMiniType<Source$Outbound, Source> =
  smartUnion([
    z.lazy(() => Card$outboundSchema),
    z.lazy(() => BankAccount$outboundSchema),
  ]);

export function sourceToJSON(source: Source): string {
  return JSON.stringify(Source$outboundSchema.parse(source));
}

/** @internal */
export type BookingPayment$Outbound = {
  amount?: number | undefined;
  currency?: string | undefined;
  source?: Card$Outbound | BankAccount$Outbound | undefined;
};

/** @internal */
export const BookingPayment$outboundSchema: z.ZodMiniType<
  BookingPayment$Outbound,
  BookingPayment
> = z.object({
  amount: z.optional(z.number()),
  currency: z.optional(Currency$outboundSchema),
  source: z.optional(
    smartUnion([
      z.lazy(() => Card$outboundSchema),
      z.lazy(() => BankAccount$outboundSchema),
    ]),
  ),
});

export function bookingPaymentToJSON(bookingPayment: BookingPayment): string {
  return JSON.stringify(BookingPayment$outboundSchema.parse(bookingPayment));
}
